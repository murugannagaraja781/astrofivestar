<!DOCTYPE html>
<html lang="ta">
<head>
  <meta charset="UTF-8" />
  <title>P2P Chat / Audio / Video</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }
    .row { margin: 8px 0; }
    input, button {
      padding: 6px 10px;
      margin: 3px;
    }
    button { cursor: pointer; }
    #myUserId {
      font-weight: bold;
      color: #1b5e20;
      word-break: break-all;
    }
    #status {
      margin-top: 8px;
      padding: 6px;
      border: 1px solid #ccc;
      min-height: 30px;
      font-size: 14px;
    }
    #typingIndicator {
      margin-top: 4px;
      font-size: 13px;
      color: #7b1fa2;
      min-height: 18px;
    }
    #timer {
      font-weight: bold;
      color: #1565c0;
    }
    video {
      width: 45%;
      border: 1px solid #ccc;
      margin-top: 10px;
    }
    #chatBox {
      border: 1px solid #ccc;
      padding: 8px;
      height: 200px;
      overflow-y: auto;
      font-size: 14px;
      margin-top: 8px;
    }
    .chat-me { color: #1b5e20; }
    .chat-other { color: #b71c1c; }
    .chat-meta { font-size: 11px; color: #555; }
    .chat-block { margin-bottom: 6px; }
    img.chat-image {
      max-width: 150px;
      max-height: 150px;
      display: block;
      margin-top: 4px;
      border: 1px solid #ccc;
    }
    audio { display: block; margin-top: 4px; }
    .msg-status {
      font-size: 11px;
      margin-left: 6px;
    }
  </style>
</head>
<body>
  <h2>P2P Chat / Audio / Video (Single Page)</h2>

  <div class="row">
    <label>‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç:
      <input id="nameInput" placeholder="‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç" />
    </label>
    <button id="registerBtn">Register</button>
  </div>

  <div class="row">
    ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç User ID:
    <span id="myUserId">(register ‡ÆÜ‡Æï‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà)</span>
  </div>

  <div class="row">
    Target User ID:
    <input id="targetUserId" placeholder="‡ÆÆ‡Æ±‡Øç‡Æ±‡Æµ‡Æ∞‡Æø‡Æ©‡Øç User ID" />
  </div>

  <div class="row">
    <button id="btnChat">Start Chat</button>
    <button id="btnAudio">Start Audio Call</button>
    <button id="btnVideo">Start Video Call</button>
    <button id="btnEnd">End Session</button>
  </div>

  <div class="row">
    Status:
    <div id="status"></div>
    <div id="typingIndicator"></div>
  </div>

  <div class="row">
    Session Timer:
    <span id="timer">00:00</span>
  </div>

  <div class="row">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <h3>Chat</h3>
  <div id="chatBox"></div>
  <div class="row">
    <input id="chatInput" placeholder="Text message type ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç" />
    <button id="chatSendBtn">Send Text</button>
  </div>
  <div class="row">
    <button id="recordAudioBtn">üéô Audio Record</button>
    <input id="fileInput" type="file" />
    <span class="chat-meta">Image / PDF / document upload ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æ≤‡Ææ‡ÆÆ‡Øç</span>
  </div>

  <!-- Socket.IO client -->
  <script src="/socket.io/socket.io.js"></script>
  <!-- Simple-peer -->
  <script src="https://unpkg.com/simple-peer/simplepeer.min.js"></script>

  <script>
    const socket = io();
    const nameInput = document.getElementById('nameInput');
    const registerBtn = document.getElementById('registerBtn');
    const myUserIdSpan = document.getElementById('myUserId');
    const targetUserIdInput = document.getElementById('targetUserId');

    const btnChat = document.getElementById('btnChat');
    const btnAudio = document.getElementById('btnAudio');
    const btnVideo = document.getElementById('btnVideo');
    const btnEnd = document.getElementById('btnEnd');

    const statusDiv = document.getElementById('status');
    const typingIndicator = document.getElementById('typingIndicator');
    const timerSpan = document.getElementById('timer');

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    const chatBox = document.getElementById('chatBox');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');

    const recordAudioBtn = document.getElementById('recordAudioBtn');
    const fileInput = document.getElementById('fileInput');

    let myUserId = null;
    let currentSession = null; // { id, type, partnerUserId, startTime, timerInterval }
    let peer = null;
    let localStream = null;

    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;

    const msgStatusSpans = {}; // messageId -> span element
    let typingTimeout = null;

    function setStatus(text) {
      statusDiv.textContent = text;
      console.log('[STATUS]', text);
    }

    function formatDuration(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = totalSeconds % 60;
      if (h > 0) {
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      }
      return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    function startTimer() {
      if (!currentSession) return;
      currentSession.startTime = Date.now();
      timerSpan.textContent = '00:00';
      if (currentSession.timerInterval) clearInterval(currentSession.timerInterval);
      currentSession.timerInterval = setInterval(() => {
        const diff = Date.now() - currentSession.startTime;
        timerSpan.textContent = formatDuration(diff);
      }, 1000);
    }

    function stopTimerAndGetDuration() {
      if (!currentSession) return 0;
      if (currentSession.timerInterval) {
        clearInterval(currentSession.timerInterval);
        currentSession.timerInterval = null;
      }
      const end = Date.now();
      const duration = end - (currentSession.startTime || end);
      timerSpan.textContent = '00:00';
      return duration;
    }

    function resetMedia() {
      if (peer) {
        peer.destroy();
        peer = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
    }

    function resetSession(sendToRemote = true) {
      if (!currentSession) return;
      const duration = stopTimerAndGetDuration();

      if (sendToRemote && duration >= 0) {
        socket.emit('session-ended', {
          sessionId: currentSession.id,
          toUserId: currentSession.partnerUserId,
          type: currentSession.type,
          durationMs: duration,
        });
      }

      setStatus(
        `Session ended. Type=${currentSession.type}, Duration=${formatDuration(duration)}`
      );

      resetMedia();
      currentSession = null;
    }

    function makeMessageId() {
      return 'm-' + Date.now() + '-' + Math.random().toString(36).slice(2);
    }

    // ===== Registration =====
    socket.on('connect', () => {
      setStatus('Socket connected: ' + socket.id);

      const savedUserId = localStorage.getItem('p2pUserId');
      const savedName = localStorage.getItem('p2pName');
      if (savedName) {
        nameInput.value = savedName;
      }
      if (savedName && savedUserId) {
        socket.emit('register', { name: savedName, existingUserId: savedUserId }, (res) => {
          if (res.ok) {
            myUserId = res.userId;
            myUserIdSpan.textContent = myUserId;
            setStatus('Re-registered with existing ID.');
          } else {
            setStatus('Auto register failed: ' + res.error);
          }
        });
      }
    });

    registerBtn.onclick = () => {
      const name = nameInput.value.trim();
      if (!name) {
        alert('‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç ‡Æé‡Æ¥‡ØÅ‡Æ§‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        return;
      }
      const existingUserId = localStorage.getItem('p2pUserId') || null;
      socket.emit('register', { name, existingUserId }, (res) => {
        if (!res.ok) {
          alert('Register error: ' + res.error);
          return;
        }
        myUserId = res.userId;
        myUserIdSpan.textContent = myUserId;
        localStorage.setItem('p2pUserId', myUserId);
        localStorage.setItem('p2pName', name);
        setStatus('Registered as ' + name + ' (' + myUserId + ')');
      });
    };

    // ===== Start session =====
    function startSession(type) {
      if (!myUserId) {
        alert('‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç register ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        return;
      }
      if (currentSession) {
        alert('Already in a session. ‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç End Session ‡ÆÖ‡Æ¥‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        return;
      }
      const targetId = targetUserIdInput.value.trim();
      if (!targetId) {
        alert('Target User ID ‡Æ§‡Øá‡Æµ‡Øà.');
        return;
      }

      socket.emit('request-session', { toUserId: targetId, type }, (res) => {
        if (!res.ok) {
          if (res.code === 'offline') {
            setStatus('User offline.');
          } else if (res.code === 'busy') {
            setStatus('User busy (already in another session).');
          } else {
            setStatus('Request failed: ' + res.error);
          }
          return;
        }
        const sessionId = res.sessionId;
        currentSession = {
          id: sessionId,
          type,
          partnerUserId: targetId,
          startTime: null,
          timerInterval: null,
        };
        setStatus(`Session request sent (${type}) to ${targetId} (sessionId=${sessionId})`);

        if (type === 'audio' || type === 'video') {
          createPeer(true, type);
        }
      });
    }

    btnChat.onclick = () => startSession('chat');
    btnAudio.onclick = () => startSession('audio');
    btnVideo.onclick = () => startSession('video');
    btnEnd.onclick = () => resetSession(true);

    // ===== Incoming session =====
    socket.on('incoming-session', ({ sessionId, fromUserId, type }) => {
      if (currentSession) {
        socket.emit('answer-session', {
          sessionId,
          toUserId: fromUserId,
          type,
          accept: false,
        });
        setStatus(
          `Received ${type} request from ${fromUserId}, but I am busy; auto-rejected.`
        );
        return;
      }

      const myId = myUserId;
      if (!myId) {
        setStatus('You are not registered; rejecting session.');
        socket.emit('answer-session', {
          sessionId,
          toUserId: fromUserId,
          type,
          accept: false,
        });
        return;
      }

      const ok = confirm(`Incoming ${type} request from ${fromUserId}. Accept?`);

      socket.emit('answer-session', {
        sessionId,
        toUserId: fromUserId,
        type,
        accept: ok,
      });

      if (!ok) {
        setStatus(`Rejected ${type} session from ${fromUserId}`);
        return;
      }

      currentSession = {
        id: sessionId,
        type,
        partnerUserId: fromUserId,
        startTime: null,
        timerInterval: null,
      };
      setStatus(`Accepted ${type} session from ${fromUserId} (sessionId=${sessionId})`);

      if (type === 'audio' || type === 'video') {
        createPeer(false, type);
      } else if (type === 'chat') {
        startTimer();
      }
    });

    // ===== Answer for caller =====
    socket.on('session-answered', ({ sessionId, fromUserId, type, accept }) => {
      if (!currentSession || currentSession.id !== sessionId) return;

      if (!accept) {
        setStatus(`${type} session rejected by ${fromUserId}`);
        resetSession(false);
        return;
      }

      setStatus(`${type} session accepted by ${fromUserId}`);
      if (type === 'chat') {
        startTimer();
      }
    });

    // ===== WebRTC Audio/Video =====
    async function createPeer(initiator, type) {
      try {
        if (type === 'audio' || type === 'video') {
          const constraints = type === 'audio'
            ? { audio: true, video: false }
            : { audio: true, video: true };

          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          localVideo.srcObject = localStream;
        }

        peer = new SimplePeer({
          initiator,
          trickle: false,
          stream: localStream || undefined,
        });

        peer.on('signal', (data) => {
          if (!currentSession) return;
          socket.emit('signal', {
            sessionId: currentSession.id,
            toUserId: currentSession.partnerUserId,
            signal: data,
          });
        });

        peer.on('stream', (remoteStream) => {
          remoteVideo.srcObject = remoteStream;
        });

        peer.on('connect', () => {
          setStatus('WebRTC connected (' + currentSession.type + ')');
          startTimer();
        });

        peer.on('error', (err) => {
          console.error('Peer error:', err);
          setStatus('Peer error: ' + err.message);
        });

        peer.on('close', () => {
          console.log('Peer closed');
        });
      } catch (err) {
        console.error('createPeer error', err);
        alert('Media error: ' + err.message);
      }
    }

    socket.on('signal', ({ sessionId, fromUserId, signal }) => {
      if (!currentSession || currentSession.id !== sessionId) return;
      if (!peer) return;
      peer.signal(signal);
    });

    // ===== Chat display helper =====
    function addChatMessage(fromLabel, isMe, content, timestamp, messageId, initialStatus) {
      const wrapper = document.createElement('div');
      wrapper.className = 'chat-block';

      const meta = document.createElement('div');
      meta.className = 'chat-meta';
      meta.textContent =
        `[${new Date(timestamp).toLocaleTimeString()}] ` +
        (isMe ? '‡Æ®‡Ææ‡Æ©‡Øç' : fromLabel);
      wrapper.appendChild(meta);

      if (content.type === 'text') {
        const span = document.createElement('div');
        span.className = isMe ? 'chat-me' : 'chat-other';
        span.textContent = content.text;
        wrapper.appendChild(span);
      } else if (content.type === 'audio') {
        const info = document.createElement('div');
        info.textContent = 'Audio message:';
        wrapper.appendChild(info);
        const audio = document.createElement('audio');
        audio.controls = true;
        audio.src = content.url;
        wrapper.appendChild(audio);
      } else if (content.type === 'file') {
        const info = document.createElement('div');
        info.textContent = 'File:';
        wrapper.appendChild(info);

        if (content.mimeType && content.mimeType.startsWith('image/')) {
          const img = document.createElement('img');
          img.src = content.url;
          img.alt = content.name || 'image';
          img.className = 'chat-image';
          wrapper.appendChild(img);
        } else {
          const link = document.createElement('a');
          link.href = content.url;
          link.target = '_blank';
          link.rel = 'noopener noreferrer';
          link.textContent = content.name || 'Download file';
          wrapper.appendChild(link);
        }
      }

      if (isMe && messageId) {
        const statusSpan = document.createElement('span');
        statusSpan.className = 'msg-status';
        statusSpan.textContent =
          initialStatus === 'seen' ? '‚úì‚úì' : '‚úì'; // single tick
        wrapper.appendChild(statusSpan);
        msgStatusSpans[messageId] = statusSpan;
      }

      chatBox.appendChild(wrapper);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // ===== Text chat send =====
    chatSendBtn.onclick = () => {
      if (!currentSession || currentSession.type !== 'chat') {
        alert('Chat session active ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.');
        return;
      }
      const text = chatInput.value.trim();
      if (!text) return;

      const toUserId = currentSession.partnerUserId;
      const sessionId = currentSession.id;
      const ts = Date.now();
      const messageId = makeMessageId();
      const content = { type: 'text', text };

      socket.emit('chat-message', {
        toUserId,
        sessionId,
        content,
        timestamp: ts,
        messageId,
      });

      addChatMessage('‡Æ®‡Ææ‡Æ©‡Øç', true, content, ts, messageId, 'sent');
      chatInput.value = '';
    };

    socket.on('chat-message', ({ fromUserId, content, sessionId, timestamp, messageId }) => {
      if (!currentSession || currentSession.id !== sessionId) return;
      addChatMessage(fromUserId, false, content, timestamp, null, null);

      // ‡Æá‡Æô‡Øç‡Æï ‡Æµ‡Æ®‡Øç‡Æ§‡Æµ‡ØÅ‡Æü‡Æ©‡Øá receiver -> sender ‡Æï‡Øç‡Æï‡ØÅ "seen" send ‡Æ™‡Æ£‡Øç‡Æ£‡ØÅ‡Æ±‡Øã‡ÆÆ‡Øç
      socket.emit('message-delivered', {
        toUserId: fromUserId,
        messageId,
      });
    });

    // ===== Tick (single/double) update =====
    socket.on('message-status', ({ messageId, status }) => {
      const span = msgStatusSpans[messageId];
      if (!span) return;
      if (status === 'sent') {
        span.textContent = '‚úì';
      } else if (status === 'seen') {
        span.textContent = '‚úì‚úì';
      }
    });

    // ===== Typing indicator =====
    function sendTyping(isTyping) {
      if (!currentSession || currentSession.type !== 'chat') return;
      socket.emit('typing', {
        toUserId: currentSession.partnerUserId,
        isTyping,
      });
    }

    chatInput.addEventListener('input', () => {
      if (!currentSession || currentSession.type !== 'chat') return;
      sendTyping(true);
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        sendTyping(false);
      }, 1200);
    });

    socket.on('typing', ({ fromUserId, isTyping }) => {
      if (!currentSession || currentSession.partnerUserId !== fromUserId) return;
      if (isTyping) {
        typingIndicator.textContent = '‡ÆÖ‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç typing‚Ä¶';
      } else {
        typingIndicator.textContent = '';
      }
    });

    // ===== Chat enter key =====
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        chatSendBtn.click();
      }
    });

    // ===== Audio record & send =====
    recordAudioBtn.onclick = async () => {
      if (!currentSession || currentSession.type !== 'chat') {
        alert('‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç chat session start ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        return;
      }

      if (!isRecording) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioChunks = [];
          mediaRecorder = new MediaRecorder(stream);

          mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size > 0) {
              audioChunks.push(e.data);
            }
          };

          mediaRecorder.onstop = async () => {
            stream.getTracks().forEach((t) => t.stop());
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            const file = new File([blob], `audio-${Date.now()}.webm`, {
              type: 'audio/webm',
            });
            await uploadAndSendFile(file, 'audio');
            isRecording = false;
            recordAudioBtn.textContent = 'üéô Audio Record';
          };

          mediaRecorder.start();
          isRecording = true;
          recordAudioBtn.textContent = '‚èπ Stop Recording';
        } catch (err) {
          console.error('Audio record error:', err);
          alert('Mic access error: ' + err.message);
        }
      } else {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
      }
    };

    // ===== File upload =====
    fileInput.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      if (!currentSession || currentSession.type !== 'chat') {
        alert('Chat session active ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç chat session start ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        fileInput.value = '';
        return;
      }

      await uploadAndSendFile(file, 'file');
      fileInput.value = '';
    };

    async function uploadAndSendFile(file, kind) {
      try {
        const fd = new FormData();
        fd.append('file', file);

        const res = await fetch('/upload', {
          method: 'POST',
          body: fd,
        });
        const json = await res.json();
        if (!json.ok) {
          alert('Upload failed: ' + json.error);
          return;
        }

        const toUserId = currentSession.partnerUserId;
        const sessionId = currentSession.id;
        const ts = Date.now();
        const messageId = makeMessageId();

        const content =
          kind === 'audio'
            ? {
                type: 'audio',
                url: json.url,
                mimeType: json.mimeType,
                name: json.originalName,
              }
            : {
                type: 'file',
                url: json.url,
                mimeType: json.mimeType,
                name: json.originalName,
              };

        socket.emit('chat-message', {
          toUserId,
          sessionId,
          content,
          timestamp: ts,
          messageId,
        });

        addChatMessage('‡Æ®‡Ææ‡Æ©‡Øç', true, content, ts, messageId, 'sent');
      } catch (err) {
        console.error('uploadAndSendFile error:', err);
        alert('Upload error: ' + err.message);
      }
    }

    // ===== Session ended from remote =====
    socket.on('session-ended', ({ sessionId, fromUserId, type, durationMs }) => {
      if (!currentSession || currentSession.id !== sessionId) return;

      stopTimerAndGetDuration();
      const d = durationMs || 0;
      setStatus(
        `Session ended by ${fromUserId}. Type=${type}, Duration=${formatDuration(d)}`
      );
      resetMedia();
      currentSession = null;
    });
  </script>
</body>
</html>
