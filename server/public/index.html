<!DOCTYPE html>
<html lang="ta">
<head>
  <meta charset="UTF-8" />
  <title>P2P Chat / Audio / Video</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }
    .row { margin: 8px 0; }
    input, button {
      padding: 6px 10px;
      margin: 3px;
    }
    button { cursor: pointer; }
    #myUserId {
      font-weight: bold;
      color: #1b5e20;
      word-break: break-all;
    }
    #status {
      margin-top: 8px;
      padding: 6px;
      border: 1px solid #ccc;
      min-height: 30px;
      font-size: 14px;
      white-space: pre-line;
    }
    #typingIndicator {
      margin-top: 4px;
      font-size: 13px;
      color: #7b1fa2;
      min-height: 18px;
    }
    #timer {
      font-weight: bold;
      color: #1565c0;
    }
    video {
      width: 45%;
      border: 1px solid #ccc;
      margin-top: 10px;
    }
    #chatBox {
      border: 1px solid #ccc;
      padding: 8px;
      height: 200px;
      overflow-y: auto;
      font-size: 14px;
      margin-top: 8px;
    }
    .chat-me { color: #1b5e20; }
    .chat-other { color: #b71c1c; }
    .chat-meta { font-size: 11px; color: #555; }
    .chat-block { margin-bottom: 6px; }
    img.chat-image {
      max-width: 150px;
      max-height: 150px;
      display: block;
      margin-top: 4px;
      border: 1px solid #ccc;
    }
    audio { display: block; margin-top: 4px; }
    .msg-status {
      font-size: 11px;
      margin-left: 6px;
    }
  </style>
</head>
<body>
  <h2>P2P Chat / Audio / Video (Single Page)</h2>

  <div class="row">
    <label>‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç:
      <input id="nameInput" placeholder="‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç" />
    </label>
    <button id="registerBtn">Register</button>
  </div>

  <div class="row">
    ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç User ID:
    <span id="myUserId">(register ‡ÆÜ‡Æï‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà)</span>
  </div>

  <div class="row">
    Target User ID:
    <input id="targetUserId" placeholder="‡ÆÆ‡Æ±‡Øç‡Æ±‡Æµ‡Æ∞‡Æø‡Æ©‡Øç User ID" />
  </div>

  <div class="row">
    <button id="btnChat">Start Chat</button>
    <button id="btnAudio">Start Audio Call</button>
    <button id="btnVideo">Start Video Call</button>
    <button id="btnEnd">End Session</button>
  </div>

  <div class="row">
    Status:
    <div id="status"></div>
    <div id="typingIndicator"></div>
  </div>

  <div class="row">
    Session Timer:
    <span id="timer">00:00</span>
  </div>

  <div class="row">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <h3>Chat</h3>
  <div id="chatBox"></div>
  <div class="row">
    <input id="chatInput" placeholder="Text message type ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç" />
    <button id="chatSendBtn">Send Text</button>
  </div>
  <div class="row">
    <button id="recordAudioBtn">üéô Audio Record</button>
    <input id="fileInput" type="file" />
    <span class="chat-meta">Image / PDF / document upload ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æ≤‡Ææ‡ÆÆ‡Øç</span>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/simple-peer/simplepeer.min.js"></script>

  <script>
    const socket = io();
    const nameInput = document.getElementById('nameInput');
    const registerBtn = document.getElementById('registerBtn');
    const myUserIdSpan = document.getElementById('myUserId');
    const targetUserIdInput = document.getElementById('targetUserId');

    const btnChat = document.getElementById('btnChat');
    const btnAudio = document.getElementById('btnAudio');
    const btnVideo = document.getElementById('btnVideo');
    const btnEnd = document.getElementById('btnEnd');

    const statusDiv = document.getElementById('status');
    const typingIndicator = document.getElementById('typingIndicator');
    const timerSpan = document.getElementById('timer');

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    const chatBox = document.getElementById('chatBox');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');

    const recordAudioBtn = document.getElementById('recordAudioBtn');
    const fileInput = document.getElementById('fileInput');

    let myUserId = null;
    let currentSession = null;
    let peer = null;
    let localStream = null;

    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;

    const msgStatusSpans = {};
    let typingTimeout = null;

    // peer ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æ©‡Øç ‡Æµ‡Æ∞‡ØÅ‡ÆÆ‡Øç signaling messages queue
    let pendingSignals = [];

    // ExpressTurn STUN/TURN
    const ICE_SERVERS = [
  // Google STUN ‚Äì ‡Æö‡Æø‡Æ≤ browser‡Æï‡Øç‡Æï‡ØÅ safe fallback
  { urls: 'stun:stun.l.google.com:19302' },

  // ExpressTurn STUN
  { urls: 'stun:relay1.expressturn.com:3478' },

  // ExpressTurn TURN ‚Äì UDP + TCP ‡Æá‡Æ∞‡Æ£‡Øç‡Æü‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æï‡Øä‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç
  {
    urls: [
      'turn:relay1.expressturn.com:3478?transport=udp',
      'turn:relay1.expressturn.com:3478?transport=tcp'
    ],
    username: '000000002080531845',
    credential: 'q4Z3wtKwfadKoxJ5dU7ghrlTmSc='
  }
];

    function logDebug() {
      console.log('[DEBUG]', ...arguments);
    }

    function setStatus(text) {
      statusDiv.textContent = text;
      console.log('[STATUS]', text);
    }

    function appendStatus(text) {
      statusDiv.textContent += '\n' + text;
      console.log('[STATUS]', text);
    }

    function formatDuration(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = totalSeconds % 60;
      if (h > 0) {
        return (
          String(h).padStart(2, '0') + ':' +
          String(m).padStart(2, '0') + ':' +
          String(s).padStart(2, '0')
        );
      }
      return (
        String(m).padStart(2, '0') + ':' +
        String(s).padStart(2, '0')
      );
    }

    function startTimer() {
      if (!currentSession) return;
      currentSession.startTime = Date.now();
      timerSpan.textContent = '00:00';
      if (currentSession.timerInterval) {
        clearInterval(currentSession.timerInterval);
      }
      currentSession.timerInterval = setInterval(() => {
        const diff = Date.now() - currentSession.startTime;
        timerSpan.textContent = formatDuration(diff);
      }, 1000);
    }

    function stopTimerAndGetDuration() {
      if (!currentSession) return 0;
      if (currentSession.timerInterval) {
        clearInterval(currentSession.timerInterval);
        currentSession.timerInterval = null;
      }
      const end = Date.now();
      const duration = end - (currentSession.startTime || end);
      timerSpan.textContent = '00:00';
      return duration;
    }

    function resetMedia() {
      if (peer) {
        logDebug('Peer destroy() called');
        peer.destroy();
        peer = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
    }

    function resetSession(sendToRemote) {
      if (!currentSession) return;
      const duration = stopTimerAndGetDuration();

      if (sendToRemote) {
        socket.emit('session-ended', {
          sessionId: currentSession.id,
          toUserId: currentSession.partnerUserId,
          type: currentSession.type,
          durationMs: duration
        });
      }

      setStatus(
        'Session ended. Type=' + currentSession.type +
        ', Duration=' + formatDuration(duration)
      );

      typingIndicator.textContent = '';
      resetMedia();
      currentSession = null;
      pendingSignals = [];
    }

    function makeMessageId() {
      return 'm-' + Date.now() + '-' + Math.random().toString(36).slice(2);
    }

    // ===== Registration =====
    socket.on('connect', () => {
      setStatus('Socket connected: ' + socket.id);

      const savedUserId = localStorage.getItem('p2pUserId');
      const savedName = localStorage.getItem('p2pName');
      if (savedName) {
        nameInput.value = savedName;
      }
      if (savedName && savedUserId) {
        logDebug('Auto-registering with saved ID', savedUserId);
        socket.emit(
          'register',
          { name: savedName, existingUserId: savedUserId },
          (res) => {
            if (res.ok) {
              myUserId = res.userId;
              myUserIdSpan.textContent = myUserId;
              setStatus('Re-registered with existing ID.');
            } else {
              setStatus('Auto register failed: ' + res.error);
            }
          }
        );
      }
    });

    registerBtn.onclick = () => {
      const name = nameInput.value.trim();
      if (!name) {
        alert('‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç ‡Æé‡Æ¥‡ØÅ‡Æ§‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        return;
      }
      const existingUserId = localStorage.getItem('p2pUserId') || null;
      logDebug('Manual register clicked. existingUserId =', existingUserId);
      socket.emit(
        'register',
        { name: name, existingUserId: existingUserId },
        (res) => {
          if (!res.ok) {
            alert('Register error: ' + res.error);
            return;
          }
          myUserId = res.userId;
          myUserIdSpan.textContent = myUserId;
          localStorage.setItem('p2pUserId', myUserId);
          localStorage.setItem('p2pName', name);
          setStatus('Registered as ' + name + ' (' + myUserId + ')');
        }
      );
    };

    // ===== Session start =====
    function startSession(type) {
      if (!myUserId) {
        alert('‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç register ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        return;
      }
      if (currentSession) {
        alert('Already in a session. ‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç End Session ‡ÆÖ‡Æ¥‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        return;
      }
      const targetId = targetUserIdInput.value.trim();
      if (!targetId) {
        alert('Target User ID ‡Æ§‡Øá‡Æµ‡Øà.');
        return;
      }

      logDebug('Requesting session', { type: type, to: targetId });
      socket.emit('request-session', { toUserId: targetId, type: type }, (res) => {
        if (!res.ok) {
          logDebug('request-session failed', res);
          if (res.code === 'offline') {
            setStatus('User offline.');
          } else if (res.code === 'busy') {
            setStatus('User busy (already in another session).');
          } else {
            setStatus('Request failed: ' + res.error);
          }
          return;
        }
        const sessionId = res.sessionId;
        currentSession = {
          id: sessionId,
          type: type,
          partnerUserId: targetId,
          startTime: null,
          timerInterval: null
        };
        pendingSignals = [];
        setStatus(
          'Session request sent (' + type + ') to ' +
          targetId + ' (sessionId=' + sessionId + ')'
        );

        if (type === 'audio' || type === 'video') {
          createPeer(true, type);
        }
      });
    }

    btnChat.onclick = function () { startSession('chat'); };
    btnAudio.onclick = function () { startSession('audio'); };
    btnVideo.onclick = function () { startSession('video'); };
    btnEnd.onclick = function () { resetSession(true); };

    // ===== Incoming session =====
    socket.on('incoming-session', function (data) {
      const sessionId = data.sessionId;
      const fromUserId = data.fromUserId;
      const type = data.type;

      logDebug('incoming-session', data);

      if (currentSession) {
        socket.emit('answer-session', {
          sessionId: sessionId,
          toUserId: fromUserId,
          type: type,
          accept: false
        });
        setStatus(
          'Received ' + type + ' request from ' + fromUserId +
          ', but I am busy; auto-rejected.'
        );
        return;
      }

      if (!myUserId) {
        setStatus('You are not registered; rejecting session.');
        socket.emit('answer-session', {
          sessionId: sessionId,
          toUserId: fromUserId,
          type: type,
          accept: false
        });
        return;
      }

      var ok = confirm(
        'Incoming ' + type + ' request from ' + fromUserId + '. Accept?'
      );

      socket.emit('answer-session', {
        sessionId: sessionId,
        toUserId: fromUserId,
        type: type,
        accept: ok
      });

      if (!ok) {
        setStatus('Rejected ' + type + ' session from ' + fromUserId);
        return;
      }

      currentSession = {
        id: sessionId,
        type: type,
        partnerUserId: fromUserId,
        startTime: null,
        timerInterval: null
      };
      pendingSignals = [];
      setStatus(
        'Accepted ' + type + ' session from ' + fromUserId +
        ' (sessionId=' + sessionId + ')'
      );

      if (type === 'audio' || type === 'video') {
        createPeer(false, type);
      } else if (type === 'chat') {
        startTimer();
      }
    });

    // ===== Answer (caller side) =====
    socket.on('session-answered', function (data) {
      const sessionId = data.sessionId;
      const fromUserId = data.fromUserId;
      const type = data.type;
      const accept = data.accept;

      logDebug('session-answered', data);

      if (!currentSession || currentSession.id !== sessionId) return;

      if (!accept) {
        setStatus(type + ' session rejected by ' + fromUserId);
        resetSession(false);
        return;
      }

      setStatus(type + ' session accepted by ' + fromUserId);
      if (type === 'chat') {
        startTimer();
      }
    });

    // ===== WebRTC with ExpressTurn ICE =====
    async function createPeer(initiator, type) {
      try {
        logDebug('createPeer called', {
          initiator: initiator,
          type: type,
          ICE_SERVERS: ICE_SERVERS
        });

        if (type === 'audio' || type === 'video') {
          var constraints =
            type === 'audio'
              ? { audio: true, video: false }
              : { audio: true, video: true };

          logDebug('Requesting getUserMedia', constraints);
          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          logDebug('getUserMedia success, stream tracks=', localStream.getTracks());
          localVideo.srcObject = localStream;
        }

        peer = new SimplePeer({
  initiator: initiator,
  trickle: false,
  stream: localStream || undefined,
  config: {
    iceServers: ICE_SERVERS,
    // ‡Æé‡Æ≤‡Øç‡Æ≤‡Ææ ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æö‡Øç‡Æö‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç browser decide ‡Æ™‡Æ£‡Øç‡Æ£‡Æø‡Æü‡Æü‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç
    iceTransportPolicy: 'all'
  }
});

        logDebug('SimplePeer created. Initiator =', initiator);

        // pending signals flush
        if (pendingSignals.length > 0) {
          logDebug('Flushing pendingSignals', pendingSignals);
          pendingSignals.forEach(function (sig) {
            peer.signal(sig);
          });
          pendingSignals = [];
        }

        if (peer._pc) {
          peer._pc.addEventListener('iceconnectionstatechange', function () {
            var state = peer._pc.iceConnectionState;
            logDebug('ICE state =', state);
            appendStatus('ICE state: ' + state);
          });

          peer._pc.addEventListener('connectionstatechange', function () {
            var state = peer._pc.connectionState;
            logDebug('PC connectionState =', state);
            appendStatus('PC connectionState: ' + state);
          });
        }

        peer.on('signal', function (data) {
          if (!currentSession) return;
          logDebug('peer signal', { hasSdp: !!data.sdp, type: data.type });
          socket.emit('signal', {
            sessionId: currentSession.id,
            toUserId: currentSession.partnerUserId,
            signal: data
          });
        });

        peer.on('stream', function (remoteStream) {
          logDebug('peer remote stream event', remoteStream.getTracks());
          remoteVideo.srcObject = remoteStream;
        });

        peer.on('connect', function () {
          logDebug('peer CONNECT event fired');
          setStatus('WebRTC connected (' + currentSession.type + ')');
          startTimer();
        });

        peer.on('error', function (err) {
          console.error('Peer error:', err);
          appendStatus('Peer error: ' + err.message);
        });

        peer.on('close', function () {
          logDebug('peer CLOSE event fired');
        });
      } catch (err) {
        console.error('createPeer error', err);
        appendStatus('Media error: ' + err.message);
        alert('Media error: ' + err.message);
      }
    }

    // ===== signaling from server ‚Üí peer / queue =====
    socket.on('signal', function (data) {
      var sessionId = data.sessionId;
      var fromUserId = data.fromUserId;
      var signal = data.signal;

      logDebug('signal from server', {
        sessionId: sessionId,
        fromUserId: fromUserId,
        type: signal.type
      });

      if (!currentSession || currentSession.id !== sessionId) {
        logDebug('signal dropped ‚Äì no matching session');
        return;
      }

      if (!peer) {
        logDebug('peer is null ‚Äì queuing signal');
        pendingSignals.push(signal);
        return;
      }

      logDebug('delivering signal to peer');
      peer.signal(signal);
    });

    // ===== Chat display =====
    function addChatMessage(fromLabel, isMe, content, timestamp, messageId, initialStatus) {
      var wrapper = document.createElement('div');
      wrapper.className = 'chat-block';

      var meta = document.createElement('div');
      meta.className = 'chat-meta';
      meta.textContent =
        '[' + new Date(timestamp).toLocaleTimeString() + '] ' +
        (isMe ? '‡Æ®‡Ææ‡Æ©‡Øç' : fromLabel);
      wrapper.appendChild(meta);

      if (content.type === 'text') {
        var span = document.createElement('div');
        span.className = isMe ? 'chat-me' : 'chat-other';
        span.textContent = content.text;
        wrapper.appendChild(span);
      } else if (content.type === 'audio') {
        var infoA = document.createElement('div');
        infoA.textContent = 'Audio message:';
        wrapper.appendChild(infoA);
        var audio = document.createElement('audio');
        audio.controls = true;
        audio.src = content.url;
        wrapper.appendChild(audio);
      } else if (content.type === 'file') {
        var infoF = document.createElement('div');
        infoF.textContent = 'File:';
        wrapper.appendChild(infoF);

        if (content.mimeType && content.mimeType.indexOf('image/') === 0) {
          var img = document.createElement('img');
          img.src = content.url;
          img.alt = content.name || 'image';
          img.className = 'chat-image';
          wrapper.appendChild(img);
        } else {
          var link = document.createElement('a');
          link.href = content.url;
          link.target = '_blank';
          link.rel = 'noopener noreferrer';
          link.textContent = content.name || 'Download file';
          wrapper.appendChild(link);
        }
      }

      if (isMe && messageId) {
        var statusSpan = document.createElement('span');
        statusSpan.className = 'msg-status';
        if (initialStatus === 'queued') statusSpan.textContent = '‚Ä¶';
        else if (initialStatus === 'seen') statusSpan.textContent = '‚úì‚úì';
        else statusSpan.textContent = '‚úì';
        wrapper.appendChild(statusSpan);
        msgStatusSpans[messageId] = statusSpan;
      }

      chatBox.appendChild(wrapper);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // ===== Text chat send =====
    chatSendBtn.onclick = function () {
      if (!currentSession || currentSession.type !== 'chat') {
        alert('Chat session active ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.');
        return;
      }
      var text = chatInput.value.trim();
      if (!text) return;

      var toUserId = currentSession.partnerUserId;
      var sessionId = currentSession.id;
      var ts = Date.now();
      var messageId = makeMessageId();
      var content = { type: 'text', text: text };

      socket.emit('chat-message', {
        toUserId: toUserId,
        sessionId: sessionId,
        content: content,
        timestamp: ts,
        messageId: messageId
      });

      addChatMessage('‡Æ®‡Ææ‡Æ©‡Øç', true, content, ts, messageId, 'sent');
      chatInput.value = '';
      sendTyping(false);
    };

    socket.on('chat-message', function (data) {
      var fromUserId = data.fromUserId;
      var content = data.content;
      var sessionId = data.sessionId;
      var timestamp = data.timestamp;
      var messageId = data.messageId;

      logDebug('chat-message received', {
        fromUserId: fromUserId,
        sessionId: sessionId,
        messageId: messageId
      });

      if (!currentSession || currentSession.id !== sessionId) return;
      addChatMessage(fromUserId, false, content, timestamp, null, null);

      socket.emit('message-delivered', {
        toUserId: fromUserId,
        messageId: messageId
      });
    });

    // ===== Tick status =====
    socket.on('message-status', function (data) {
      var messageId = data.messageId;
      var status = data.status;
      var span = msgStatusSpans[messageId];
      if (!span) return;
      if (status === 'queued') {
        span.textContent = '‚Ä¶';
      } else if (status === 'sent') {
        span.textContent = '‚úì';
      } else if (status === 'seen') {
        span.textContent = '‚úì‚úì';
      }
    });

    // ===== Typing indicator =====
    function sendTyping(isTyping) {
      if (!currentSession || currentSession.type !== 'chat') return;
      socket.emit('typing', {
        toUserId: currentSession.partnerUserId,
        isTyping: isTyping
      });
    }

    chatInput.addEventListener('input', function () {
      if (!currentSession || currentSession.type !== 'chat') return;
      sendTyping(true);
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(function () {
        sendTyping(false);
      }, 1200);
    });

    socket.on('typing', function (data) {
      var fromUserId = data.fromUserId;
      var isTyping = data.isTyping;

      if (!currentSession || currentSession.type !== 'chat') return;
      if (currentSession.partnerUserId !== fromUserId) return;
      typingIndicator.textContent = isTyping ? '‡ÆÖ‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç typing‚Ä¶' : '';
    });

    chatInput.addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        chatSendBtn.click();
      }
    });

    // ===== Audio record & send (chat message) =====
    recordAudioBtn.onclick = async function () {
      if (!currentSession || currentSession.type !== 'chat') {
        alert('‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç chat session start ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        return;
      }

      if (!isRecording) {
        try {
          var stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioChunks = [];
          mediaRecorder = new MediaRecorder(stream);

          mediaRecorder.ondataavailable = function (e) {
            if (e.data && e.data.size > 0) {
              audioChunks.push(e.data);
            }
          };

          mediaRecorder.onstop = async function () {
            stream.getTracks().forEach(function (t) { t.stop(); });
            var blob = new Blob(audioChunks, { type: 'audio/webm' });
            var file = new File(
              [blob],
              'audio-' + Date.now() + '.webm',
              { type: 'audio/webm' }
            );
            await uploadAndSendFile(file, 'audio');
            isRecording = false;
            recordAudioBtn.textContent = 'üéô Audio Record';
          };

          mediaRecorder.start();
          isRecording = true;
          recordAudioBtn.textContent = '‚èπ Stop Recording';
        } catch (err) {
          console.error('Audio record error:', err);
          alert('Mic access error: ' + err.message);
        }
      } else {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
      }
    };

    // ===== File upload =====
    fileInput.onchange = async function (e) {
      var file = e.target.files[0];
      if (!file) return;
      if (!currentSession || currentSession.type !== 'chat') {
        alert('Chat session active ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç chat session start ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.');
        fileInput.value = '';
        return;
      }

      await uploadAndSendFile(file, 'file');
      fileInput.value = '';
    };

    async function uploadAndSendFile(file, kind) {
      try {
        var fd = new FormData();
        fd.append('file', file);

        var res = await fetch('/upload', {
          method: 'POST',
          body: fd
        });
        var json = await res.json();
        if (!json.ok) {
          alert('Upload failed: ' + json.error);
          return;
        }

        var toUserId = currentSession.partnerUserId;
        var sessionId = currentSession.id;
        var ts = Date.now();
        var messageId = makeMessageId();

        var content;
        if (kind === 'audio') {
          content = {
            type: 'audio',
            url: json.url,
            mimeType: json.mimeType,
            name: json.originalName
          };
        } else {
          content = {
            type: 'file',
            url: json.url,
            mimeType: json.mimeType,
            name: json.originalName
          };
        }

        socket.emit('chat-message', {
          toUserId: toUserId,
          sessionId: sessionId,
          content: content,
          timestamp: ts,
          messageId: messageId
        });

        addChatMessage('‡Æ®‡Ææ‡Æ©‡Øç', true, content, ts, messageId, 'sent');
      } catch (err) {
        console.error('uploadAndSendFile error', err);
        alert('Upload error: ' + err.message);
      }
    }

    // ===== Session ended from remote =====
    socket.on('session-ended', function (data) {
      var sessionId = data.sessionId;
      var fromUserId = data.fromUserId;
      var type = data.type;
      var durationMs = data.durationMs;

      logDebug('session-ended (remote)', data);

      if (!currentSession || currentSession.id !== sessionId) return;

      stopTimerAndGetDuration();
      var d = durationMs || 0;
      setStatus(
        'Session ended by ' + fromUserId +
        '. Type=' + type +
        ', Duration=' + formatDuration(d)
      );
      typingIndicator.textContent = '';
      resetMedia();
      currentSession = null;
      pendingSignals = [];
    });
  </script>
</body>
</html>
